// Generated by CoffeeScript 1.4.0

/*
kvs converts between a set of flat key/value pairs that follows a naming convention on the key
into a nested object, and back.

The convention of the key naming goes like this.

key.sub-key1.sub-key2

which will be converted into

{ key: { 'subKey1' : { 'subKey2' ... } }}

The period is the delimiter between the nesting.

The sub-key1 gets converted into camel case if it uses dash as delimiters.

If at a given level, all of the keys are of numeric values, then it will be converted into an Array instead.

Terminology

flatKVS => a flat key/value objects with keys following the patterns described above. Note the value cannot be an array at the moment, as array is used for intermediary representation. It can be converted into a nestedKVS.

nestedKVS => a hierarchical key/value objects. It is basically any JSON object.

interKVS => this is a special form of array object that holds an array that contains splitted keys and the value object, used for unflattening.

An example is a bit easier to see between the 3 forms of data.

flatKVS =
  'avatar.0.height': 15
  'avatar.0.girth': 10
  'avatar.1.eyebrows': 5
  'scene.camera-pos-x': 1.5
  'scene.camera-pos-y': 10
  'scene.camera-pos-z': 100
  'image.width': 240
  'image.height': 296

interKVS =
  [[['avatar','0','height'],15]
   [['avatar','0','girth'],10]
   [['avatar','1','eyebrow'],5]
   [['scene','cameraPosX'],1.5]
   [['scene','cameraPosY'],10]
   [['scene','cameraPosZ'],100]
   [['image','width'], 240]
   [['image','height'],296]
  ]

nestedKVS =
  avatar:
    [{height: 15, girth: 10}
     {eyebrow: 5}]
  scene:
    cameraPosX: 1.5
    cameraPosY: 10
    cameraPosZ: 100
  image:
    width: 240
    height: 296

interKVS is only used when "unflattening" from flatKVS to nestedKVS; "flattening" does not require interKVS. This is not exposed; it is only described as an aid to understand this code.
*/


(function() {
  var camelCasing, capitalize, flattenHelper, flattenKVS, isInterKVS, toArray, toInterKVS, toNestedKVS, toObject, transformKVS, unCamelCasing, unflattenKVS,
    __slice = [].slice;

  capitalize = function(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  };

  camelCasing = function(key) {
    var head, res, s, tail, _ref;
    _ref = key.split("-"), head = _ref[0], tail = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
    res = [head].concat(__slice.call((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = tail.length; _i < _len; _i++) {
          s = tail[_i];
          _results.push(capitalize(s));
        }
        return _results;
      })()));
    return res.join("");
  };

  toInterKVS = function(flatKVS) {
    var k, keys, v, _results;
    _results = [];
    for (k in flatKVS) {
      v = flatKVS[k];
      keys = k.split(".");
      _results.push([
        (function() {
          var _i, _len, _results1;
          _results1 = [];
          for (_i = 0, _len = keys.length; _i < _len; _i++) {
            k = keys[_i];
            _results1.push(camelCasing(k));
          }
          return _results1;
        })(), v
      ]);
    }
    return _results;
  };

  toArray = function(obj) {
    var key, result, val;
    result = [];
    for (key in obj) {
      val = obj[key];
      result[key] = val;
    }
    return result;
  };

  isInterKVS = function(obj) {
    return obj instanceof Array;
  };

  toNestedKVS = function(interKVS) {
    var allNumeric, key, keys, result, val, _i, _len, _ref, _ref1;
    result = {};
    for (_i = 0, _len = interKVS.length; _i < _len; _i++) {
      _ref = interKVS[_i], (_ref1 = _ref[0], key = _ref1[0], keys = 2 <= _ref1.length ? __slice.call(_ref1, 1) : []), val = _ref[1];
      if (keys.length === 0) {
        if (result[key]) {
          throw "kvs duplicate " + key;
        }
        result[key] = val;
      } else {
        if (!result[key]) {
          result[key] = [];
        }
        result[key].push([keys, val]);
      }
    }
    allNumeric = true;
    for (key in result) {
      val = result[key];
      if (isNaN(key, Number)) {
        allNumeric = false;
      }
      if (isInterKVS(val)) {
        result[key] = toNestedKVS(val);
      }
    }
    if (allNumeric) {
      return toArray(result);
    } else {
      return result;
    }
  };

  unflattenKVS = function(flatKVS) {
    return toNestedKVS(toInterKVS(flatKVS));
  };

  toObject = function(ary) {
    var key, result, val, _i, _len, _ref;
    result = {};
    for (_i = 0, _len = ary.length; _i < _len; _i++) {
      _ref = ary[_i], key = _ref[0], val = _ref[1];
      if (result[key]) {
        throw "duplicate flattenKVS key " + key;
      }
      result[key] = val;
    }
    return result;
  };

  unCamelCasing = function(key) {
    return key.replace(/([A-Z])/g, function($1) {
      return "-" + ($1.toLowerCase());
    });
  };

  flattenHelper = function(nestedKVS, prefix) {
    var i, key, makeKey, process, result, val, _i, _len;
    makeKey = prefix === '' ? function(key) {
      return key;
    } : function(key) {
      return "" + prefix + "." + key;
    };
    process = function(key, val) {
      var newKey;
      newKey = makeKey(key);
      if ((val instanceof Array) || (val instanceof Object)) {
        return flattenHelper(val, newKey);
      } else {
        return [[unCamelCasing(newKey), val]];
      }
    };
    result = [];
    if (nestedKVS instanceof Array) {
      for (i = _i = 0, _len = nestedKVS.length; _i < _len; i = ++_i) {
        val = nestedKVS[i];
        result = result.concat(process(i, val));
      }
    } else {
      for (key in nestedKVS) {
        val = nestedKVS[key];
        result = result.concat(process(key, val));
      }
    }
    return result;
  };

  flattenKVS = function(nestedKVS) {
    return toObject(flattenHelper(nestedKVS, ''));
  };

  module.exports.unflatten = unflattenKVS;

  module.exports.flatten = flattenKVS;

  /*
  transform the object returned by optimist into what we expect as a full kvs.
  optimist also uses '.' as the object separator and automatically aggregate the command line object
  the same way.
  
  It differs from kvs in the following significant way:
  - it does not convert an object with all numeric indexes into arrays.
  - it does not convert dashes into camel casing.
  
  the transform function below handles conversion.
  */


  transformKVS = module.exports.transform = function(obj) {
    var allNumeric, key, out, result, val;
    result = {};
    allNumeric = true;
    for (key in obj) {
      val = obj[key];
      if (isNaN(key)) {
        key = camelCasing(key);
        allNumeric = false;
      }
      if (val instanceof Object) {
        result[key] = transformKVS(val);
      } else {
        result[key] = val;
      }
    }
    if (allNumeric) {
      out = [];
      for (key in result) {
        val = result[key];
        out[key] = val;
      }
      return out;
    } else {
      return result;
    }
  };

}).call(this);
