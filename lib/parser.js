// Generated by CoffeeScript 1.4.0
(function() {
  var EventEmitter, Node, ParseStack, entities, htmlParser, loglet, parse1, parseDocument, parseElement, parser, _;

  htmlParser = require('htmlparser2');

  EventEmitter = require('events').EventEmitter;

  _ = require('underscore');

  loglet = require('loglet');

  entities = require('./entities');

  Node = require('./node');

  ParseStack = (function() {

    function ParseStack() {
      this.Element = Node.type(Node.ELEMENT_NODE);
      this.root = new this.Element('__', {});
      this.stack = [this.root];
    }

    ParseStack.prototype.level = function() {
      return this.stack.length;
    };

    ParseStack.prototype.current = function() {
      if (this.stack.length === 0) {
        return null;
      } else {
        return this.stack[this.stack.length - 1];
      }
    };

    ParseStack.prototype.rootElement = function() {
      var children;
      children = this.root.children();
      if (children.length === 1) {
        return children[0];
      } else {
        return this.root;
      }
    };

    ParseStack.prototype.decode = function(val) {
      return entities.decode(val);
    };

    ParseStack.prototype.normalizeAttrs = function(attrs) {
      var key, result, val;
      result = {};
      for (key in attrs) {
        val = attrs[key];
        result[key] = this.decode(val);
      }
      return result;
    };

    ParseStack.prototype.push = function(name, attrs) {
      return this._pushElement(new this.Element(name, this.normalizeAttrs(attrs)));
    };

    ParseStack.prototype._pushElement = function(elt) {
      if (this.root === null) {
        this.root = elt;
        return this.stack.push(elt);
      } else {
        this.current().append(elt);
        return this.stack.push(elt);
      }
    };

    ParseStack.prototype.pushText = function(txt) {
      if (this.level() > 0) {
        return this.current().append(this.decode(txt));
      }
    };

    ParseStack.prototype.pop = function(name) {
      if (this.level() > 0) {
        return this.stack.pop();
      }
    };

    ParseStack.prototype.tabify = function(count) {
      var i;
      return ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
          _results.push('  ');
        }
        return _results;
      })()).join('');
    };

    ParseStack.prototype.printClose = function() {
      var elt, i, items, line, _i, _len, _ref, _results;
      items = (function() {
        var _i, _len, _ref, _results;
        _ref = this.stack;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          elt = _ref[i];
          _results.push(this.tabify(i) + '</' + elt.element);
        }
        return _results;
      }).call(this);
      _ref = items.reverse();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        _results.push(loglet.debug('parseStack.close', line));
      }
      return _results;
    };

    ParseStack.prototype.printOpen = function() {
      var elt, i, _i, _len, _ref, _results;
      _ref = this.stack;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        elt = _ref[i];
        _results.push(loglet.debug('parseStack.open', this.tabify(i) + '<' + elt.element));
      }
      return _results;
    };

    return ParseStack;

  })();

  parse1 = function(data, options) {
    var handler, parseStack, parser;
    if (options == null) {
      options = {
        xmlMode: true
      };
    }
    parseStack = new ParseStack();
    handler = {
      onopentag: function(name, attr) {
        parseStack.push(name, attr);
        return parseStack.printOpen();
      },
      ontext: function(txt) {
        return parseStack.pushText(txt);
      },
      onclosetag: function(name) {
        parseStack.printClose();
        return parseStack.pop(name);
      }
    };
    parser = new htmlParser.Parser(handler, options);
    parser.write(data);
    parser.end();
    return parseStack.rootElement();
  };

  parseDocument = function(text, options) {
    var Document, document, elt;
    Document = Node.type(Node.DOCUMENT_NODE);
    document = (function() {
      if (typeof text === 'string') {
        elt = parse1(text, options);
        loglet.debug('parseDocument', text, elt.outerHTML());
        return new Document(elt);
      } else if (text instanceof Object && text.element) {
        return new Document(text);
      } else {
        throw {
          error: 'unknown_document_structure',
          document: text
        };
      }
    })();
    return document;
  };

  parseElement = function(text, document, options) {
    var element;
    if (options == null) {
      options = {
        xmlMode: true
      };
    }
    element = parse1(text, options);
    element.setOwnerDocument(document);
    return element;
  };

  parser = {
    parseDocument: parseDocument,
    parseElement: parseElement
  };

  Node.registerParser(parser);

  module.exports = parser;

}).call(this);
